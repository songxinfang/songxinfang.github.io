<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      转载：自定义 Layer 属性的动画 | songxinfang&#39;s blog 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="songxinfang">
    
    

    <meta name="description" content="本文翻译自 http://www.objc.io/issue-12/animating-custom-layer-properties.html
原作者：Nick Lockwood
译者：@nixzhu
==========================================
默认情况下，CALayer 及其子类的绝大部分标准属性都可以执行动画，无论是添加一个 CAAnimation">
<meta property="og:type" content="article">
<meta property="og:title" content="转载：自定义 Layer 属性的动画 | songxinfang's blog">
<meta property="og:url" content="https://songxinfang.github.io/2016/11/10/2014-05-10-animating-custom-layer-properties/index.html">
<meta property="og:site_name" content="songxinfang's blog">
<meta property="og:description" content="本文翻译自 http://www.objc.io/issue-12/animating-custom-layer-properties.html
原作者：Nick Lockwood
译者：@nixzhu
==========================================
默认情况下，CALayer 及其子类的绝大部分标准属性都可以执行动画，无论是添加一个 CAAnimation">
<meta property="og:image" content="http://www.objc.io/images/issue-12/clock.gif">
<meta property="og:image" content="http://www.objc.io/images/issue-12/clock2.gif">
<meta property="og:image" content="https://github.com/nixzhu/dev-blog/raw/master/images/nixzhu_alipay.png">
<meta property="og:updated_time" content="2016-11-10T01:48:23.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="转载：自定义 Layer 属性的动画 | songxinfang's blog">
<meta name="twitter:description" content="本文翻译自 http://www.objc.io/issue-12/animating-custom-layer-properties.html
原作者：Nick Lockwood
译者：@nixzhu
==========================================
默认情况下，CALayer 及其子类的绝大部分标准属性都可以执行动画，无论是添加一个 CAAnimation">
<meta name="twitter:image" content="http://www.objc.io/images/issue-12/clock.gif">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">
    <link rel="stylesheet" href="/css/china-social-icon.css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">songxinfang&#39;s blog</a></h1>
        <hr class="panel-cover__divider" />

        
        <p class="panel-cover__description">
          learning work communicate
        </p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>
              
                
                <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">转载：自定义 Layer 属性的动画</h1>

    

    <div class="post-meta">
      <time datetime="2016-11-10" class="post-meta__date date">2016-11-10</time> 

      <span class="post-meta__tags tags">

          

          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <p>本文翻译自 <a href="http://www.objc.io/issue-12/animating-custom-layer-properties.html" target="_blank" rel="external">http://www.objc.io/issue-12/animating-custom-layer-properties.html</a></p>
<p>原作者：<a href="http://twitter.com/nicklockwood" target="_blank" rel="external">Nick Lockwood</a></p>
<p>译者：<a href="https://twitter.com/nixzhu" target="_blank" rel="external">@nixzhu</a></p>
<p>==========================================</p>
<p>默认情况下，<code>CALayer</code> 及其子类的绝大部分标准属性都可以执行动画，无论是添加一个 <code>CAAnimation</code> 到 Layer（显式动画），亦或是为属性指定一个动作然后修改它（隐式动画）。</p>
<p>但有时候我们希望能同时为好几个属性添加动画，使它们看起来像是一个动画一样；或者，我们需要执行的动画不能通过使用标准 Layer 属性动画来实现。</p>
<p>在本文中，我们将讨论如何子类化 <code>CALayer</code> 并添加我们自己的属性，以便比较容易地创建那些如果以其他方式实现起来会很麻烦的动画效果。</p>
<p>一般说来，我们希望添加到 <code>CALayer</code> 的子类上的可动画属性有三种类型：</p>
<ul>
<li>能间接动画 Layer （或其子类）的一个或多个标准属性的属性。</li>
<li>能触发 Layer 的支持图像（backing image）（即 <code>contents</code> 属性）重绘的属性。</li>
<li>不涉及 Layer 重绘或对任何已有属性执行动画的属性。</li>
</ul>
<h2 id="间接属性动画"><a href="#间接属性动画" class="headerlink" title="间接属性动画"></a>间接属性动画</h2><p>能间接修改其它标准 Layer 属性的自定义属性是这些选项中最简单的。它们真的只是自定义 setter 方法以将它们的输入转换为适用于创建动画的一个或多个不同的值。</p>
<p>如果被我们设置的属性已经预设好标准动画，那我们完全不需要编写任何实际的动画代码，因为我们修改这些属性后，它们就会继承任何被配置在当前 <code>CATransaction</code> 上的动画设置，并且自动执行动画。</p>
<p>换句话说，即使 <code>CALayer</code> 不知道如何对我们自定义的属性进行动画，它依然能对因自定义属性被改变而引起的其它可见副作用进行动画，而这恰好就是我们所关心的全部内容。</p>
<p>为了演示这种方法，让我们来创建一个简单的模拟时钟，之后我们可以使用被声明为 <code>NSDate</code> 类型 <code>time</code> 属性来设置它的时间。我会将从创建一个静态的时钟面盘开始。这个时钟包含三个 <code>CAShapeLayer</code> 实例——一个用于时钟面盘的圆形 Layer 和两个用于时针和分针的长方形 Sublayer。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">@interface ClockFace: CAShapeLayer</div><div class="line"></div><div class="line">@property (nonatomic, strong) NSDate *time;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface ClockFace ()</div><div class="line"></div><div class="line">// 私有属性，译者注：这里申明的是 CALayer ，下面分配的却是 CAShapeLayer ，按照文字，应该都是 CAShapeLayer 才对</div><div class="line">@property (nonatomic, strong) CALayer *hourHand;</div><div class="line">@property (nonatomic, strong) CALayer *minuteHand;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ClockFace</div><div class="line"></div><div class="line">- (id)init</div><div class="line">&#123;</div><div class="line">    if ((self = [super init]))</div><div class="line">    &#123;</div><div class="line">        self.bounds = CGRectMake(0, 0, 200, 200);</div><div class="line">        self.path = [UIBezierPath bezierPathWithOvalInRect:self.bounds].CGPath;</div><div class="line">        self.fillColor = [UIColor whiteColor].CGColor;</div><div class="line">        self.strokeColor = [UIColor blackColor].CGColor;</div><div class="line">        self.lineWidth = 4;</div><div class="line"></div><div class="line">        self.hourHand = [CAShapeLayer layer];</div><div class="line">        self.hourHand.path = [UIBezierPath bezierPathWithRect:CGRectMake(-2, -70, 4, 70)].CGPath;</div><div class="line">        self.hourHand.fillColor = [UIColor blackColor].CGColor;</div><div class="line">        self.hourHand.position = CGPointMake(self.bounds.size.width / 2, self.bounds.size.height / 2);</div><div class="line">        [self addSublayer:self.hourHand];</div><div class="line"></div><div class="line">        self.minuteHand = [CAShapeLayer layer];</div><div class="line">        self.minuteHand.path = [UIBezierPath bezierPathWithRect:CGRectMake(-1, -90, 2, 90)].CGPath;</div><div class="line">        self.minuteHand.fillColor = [UIColor blackColor].CGColor;</div><div class="line">        self.minuteHand.position = CGPointMake(self.bounds.size.width / 2, self.bounds.size.height / 2);</div><div class="line">        [self addSublayer:self.minuteHand];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>同时我们要设置一个基本的 View Controller ，它包含一个 <code>UIDatePicker</code> ，这样我们就能测试我们的 Layer （日期选择器在 Storyboard 里设置）了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, strong) IBOutlet UIDatePicker *datePicker;</div><div class="line">@property (nonatomic, strong) ClockFace *clockFace;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line"></div><div class="line">    // 添加时钟面板 Layer</div><div class="line">    self.clockFace = [[ClockFace alloc] init];</div><div class="line">    self.clockFace.position = CGPointMake(self.view.bounds.size.width / 2, 150);</div><div class="line">    [self.view.layer addSublayer:self.clockFace];</div><div class="line"></div><div class="line">    // 设置默认时间</div><div class="line">    self.clockFace.time = [NSDate date];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (IBAction)setTime</div><div class="line">&#123;</div><div class="line">    self.clockFace.time = self.datePicker.date;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>现在我们只需要实现 <code>time</code> 属性的 setter 方法。这个方法使用 <code>NSCalendar</code> 将时间变为小时和分钟，之后我们将它们转换为角坐标。然后我们就可以使用这些角度去生成两个 <code>CGAffineTransform</code> 以旋转时针和分针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)setTime:(NSDate *)time</div><div class="line">&#123;</div><div class="line">    _time = time;</div><div class="line"></div><div class="line">    NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar];</div><div class="line">    NSDateComponents *components = [calendar components:NSHourCalendarUnit | NSMinuteCalendarUnit fromDate:time];</div><div class="line">    self.hourHand.affineTransform = CGAffineTransformMakeRotation(components.hour / 12.0 * 2.0 * M_PI);</div><div class="line">    self.minuteHand.affineTransform = CGAffineTransformMakeRotation(components.minute / 60.0 * 2.0 * M_PI);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果看起来像这样：</p>
<p><img src="http://www.objc.io/images/issue-12/clock.gif" width="320px"></p>
<p>你可以 <a href="https://github.com/objcio/issue-12-custom-layer-property-animations" target="_blank" rel="external">从 GitHub 上</a> 下载这个项目看看。</p>
<p>如你所见，我们实在没有做什么太费脑筋的事情；我们并没有创建一个新的可动画属性，而只是在单个方法里设置了几个标准可动画 Layer 属性而已。因此，如果我们想创建的动画并不能映射到任何已有的 Layer 属性上时，该怎么办呢？</p>
<h2 id="对-Layer-的内容执行动画"><a href="#对-Layer-的内容执行动画" class="headerlink" title="对 Layer 的内容执行动画"></a>对 Layer 的内容执行动画</h2><p>假设不使用几个分离的 Layer 来实现我们的时钟面板，那我们可以改用 Core Graphics 来绘制时钟。（这通常会降低性能，但我们可以假想我们所要实现的效果需要许多复杂的绘图操作，而它们很难用常规的 Layer 属性和 transform 来复制。）我们要怎么做呢？</p>
<p>很类似 <code>NSManagedObject</code> ， <code>CALayer</code> 具有为任何被声明的属性生成动态 setter 和 getter 的能力。在当前的实现中，我们是让编译器去合成 <code>time</code> 属性的 ivar 和 getter 方法，而我们自己实现了 setter 方法。但让我们来改变一下：丢弃我们的 setter 并将属性标记为 <code>@dynamic</code> 。同时我们也丢弃分离的时针和分针 Layer ，因为我们将自己去绘制它们。</p>
<blockquote>
<p>译者注：没使用过 <code>@dynamic</code> 这样的高级货，心中还有点小激动呢！</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@interface ClockFace ()</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">@implementation ClockFace</div><div class="line"></div><div class="line">@dynamic time;</div><div class="line"></div><div class="line">- (id)init</div><div class="line">&#123;</div><div class="line">    if ((self = [super init]))</div><div class="line">    &#123;</div><div class="line">        self.bounds = CGRectMake(0, 0, 200, 200);</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在我们开始做事之前，需要先做一个小调整：因为不幸的是，<code>CALayer</code> 不知道如何对 <code>NSDate</code> 属性进行插值（interpolate）（例如，它不能自动生成 <code>NSDate</code> 实例之间的中间值，虽然它可以处理数字类型和其它例如 <code>CGColor</code> 和 <code>CGAffineTransform</code> 这样的类型）。我们可以保留我们的自定义 setter 方法并用它设置另一个动态属性（它表示等价的 <code>NSTimeInterval</code>，这是一个数字值，可以被插值），但为了保持例子的简单性，我们会用一个浮点值替换 <code>NSDate</code> 属性来表征时钟的小时，为了更新用户界面，我们使用一个简单的 <code>UITextField</code> 来设置浮点值，不再使用日期选择器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">@interface ViewController () &lt;UITextFieldDelegate&gt;</div><div class="line"></div><div class="line">@property (nonatomic, strong) IBOutlet UITextField *textField;</div><div class="line">@property (nonatomic, strong) ClockFace *clockFace;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line"></div><div class="line">    // 添加时钟面板 Layer</div><div class="line">    self.clockFace = [[ClockFace alloc] init];</div><div class="line">    self.clockFace.position = CGPointMake(self.view.bounds.size.width / 2, 150);</div><div class="line">    [self.view.layer addSublayer:self.clockFace];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (BOOL)textFieldShouldReturn:(UITextField *)textField</div><div class="line">&#123;</div><div class="line">    [textField resignFirstResponder];</div><div class="line">    return YES;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)textFieldDidEndEditing:(UITextField *)textField</div><div class="line">&#123;</div><div class="line">    self.clockFace.time = [textField.text floatValue];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>现在，既然我们已经移除了自定义的 setter 方法，那我们要如何才能知晓 <code>time</code> 属性的改变呢？我们需要一个无论何时 <code>time</code> 属性改变时都能自动通知 <code>CALayer</code> 的方式，这样它才好重绘它的内容。我们通过覆写 <code>+needsDisplayForKey:</code> 方法即可做到这一点，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)needsDisplayForKey:(NSString *)key</div><div class="line">&#123;</div><div class="line">    if ([@&quot;time&quot; isEqualToString:key])</div><div class="line">    &#123;</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    return [super needsDisplayForKey:key];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就告诉了 Layer ，无论何时 <code>time</code> 属性被修改，它都需要调用 <code>-display</code> 方法。现在我们就覆写 <code>-display</code> 方法，添加一个 <code>NSLog</code> 语句打印出 <code>time</code> 的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)display</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;time: %f&quot;, self.time);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们设置 <code>time</code> 属性为 1.5 ，我们就会看到 <code>-display</code> 被调用，打印出新值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2014-04-28 22:37:04.253 ClockFace[49145:60b] time: 1.500000</div></pre></td></tr></table></figure>
<p>但这还不是我们真正想要的；我们希望 <code>time</code> 属性能在旧值和新值之间有多个帧长的平滑的过渡动画。为了实现这一点，我们需要为 <code>time</code> 属性指定一个动画（或“动作（action）”），而通过覆写 <code>-actionForKey:</code> 方法就能做到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (id&lt;CAAction&gt;)actionForKey:(NSString *)key</div><div class="line">&#123;</div><div class="line">    if ([key isEqualToString:@&quot;time&quot;])</div><div class="line">    &#123;</div><div class="line">        CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:key];</div><div class="line">        animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear];</div><div class="line">        animation.fromValue = @(self.time);</div><div class="line">        return animation;</div><div class="line">    &#125;</div><div class="line">    return [super actionForKey:key];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在，如果我们再次设置 <code>time</code> 属性，我们就会看到 <code>-display</code> 被多次调用。调用的次数大约为每秒 60 次，至于动画的长度，默认为 0.25 秒，大约是 15 帧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">2014-04-28 22:37:04.253 ClockFace[49145:60b] time: 1.500000</div><div class="line">2014-04-28 22:37:04.255 ClockFace[49145:60b] time: 1.500000</div><div class="line">2014-04-28 22:37:04.351 ClockFace[49145:60b] time: 1.500000</div><div class="line">2014-04-28 22:37:04.370 ClockFace[49145:60b] time: 1.500000</div><div class="line">2014-04-28 22:37:04.388 ClockFace[49145:60b] time: 1.500000</div><div class="line">2014-04-28 22:37:04.407 ClockFace[49145:60b] time: 1.500000</div><div class="line">2014-04-28 22:37:04.425 ClockFace[49145:60b] time: 1.500000</div><div class="line">2014-04-28 22:37:04.443 ClockFace[49145:60b] time: 1.500000</div><div class="line">2014-04-28 22:37:04.461 ClockFace[49145:60b] time: 1.500000</div><div class="line">2014-04-28 22:37:04.479 ClockFace[49145:60b] time: 1.500000</div><div class="line">2014-04-28 22:37:04.497 ClockFace[49145:60b] time: 1.500000</div><div class="line">2014-04-28 22:37:04.515 ClockFace[49145:60b] time: 1.500000</div><div class="line">2014-04-28 22:37:04.755 ClockFace[49145:60b] time: 1.500000</div></pre></td></tr></table></figure>
<p>But for some reason when we log the <code>time</code> value at each of these intermediate points, we are still seeing the final value. Why aren’t we getting the interpolated values? The reason is that we are looking at the wrong <code>time</code> property.</p>
<p>由于某些原因，当我们在每个中间点打印 <code>time</code> 值时，我们一直看到的是最终值。为何不能得到插值呢？因为我们查看的是错误的 <code>time</code> 属性。</p>
<p>当你设置某个 <code>CALayer</code> 的某个属性，你实际设置的是 <em>model</em> Layer 的值——这里的 <em>model</em> Layer 表示正在进行的动画结束时， Layer 所达到的最终状态。如果你取 <em>model</em> Layer 的值，它就总是给你它被设置到的最终值。</p>
<p>但连接到 <em>model</em> Layer 的是所谓的 <em>presentation</em> Layer ——它是 <em>model</em> Layer 的一个拷贝，但它的值所表示的是 <em>当前的</em>，中间动画状态。如果我们修改 <code>-display</code> 方法去打印 Layer 的 <code>presentationLayer</code> 的 <code>time</code> 属性，那我们就会看到我们所期望的插值。（同时我们也使用 <code>presentationLayer</code> 的 <code>time</code> 属性来获取动画的开始值，替代 <code>self.time</code> ）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (id&lt;CAAction&gt;)actionForKey:(NSString *)key</div><div class="line">&#123;</div><div class="line">    if ([key isEqualToString:@&quot;time&quot;])</div><div class="line">    &#123;</div><div class="line">        CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:key];</div><div class="line">        animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear];</div><div class="line">        animation.fromValue = @([[self presentationLayer] time]);</div><div class="line">        return animation;</div><div class="line">    &#125;</div><div class="line">    return [super actionForKey:key];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)display</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;time: %f&quot;, [[self presentationLayer] time]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是打印出的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">2014-04-28 22:43:31.200 ClockFace[49176:60b] time: 0.000000</div><div class="line">2014-04-28 22:43:31.203 ClockFace[49176:60b] time: 0.002894</div><div class="line">2014-04-28 22:43:31.263 ClockFace[49176:60b] time: 0.363371</div><div class="line">2014-04-28 22:43:31.300 ClockFace[49176:60b] time: 0.586421</div><div class="line">2014-04-28 22:43:31.318 ClockFace[49176:60b] time: 0.695179</div><div class="line">2014-04-28 22:43:31.336 ClockFace[49176:60b] time: 0.803713</div><div class="line">2014-04-28 22:43:31.354 ClockFace[49176:60b] time: 0.912598</div><div class="line">2014-04-28 22:43:31.372 ClockFace[49176:60b] time: 1.021573</div><div class="line">2014-04-28 22:43:31.391 ClockFace[49176:60b] time: 1.134173</div><div class="line">2014-04-28 22:43:31.409 ClockFace[49176:60b] time: 1.242892</div><div class="line">2014-04-28 22:43:31.427 ClockFace[49176:60b] time: 1.352016</div><div class="line">2014-04-28 22:43:31.446 ClockFace[49176:60b] time: 1.460729</div><div class="line">2014-04-28 22:43:31.464 ClockFace[49176:60b] time: 1.500000</div><div class="line">2014-04-28 22:43:31.636 ClockFace[49176:60b] time: 1.500000</div></pre></td></tr></table></figure>
<p>所以现在我们所要做就是画出时钟。我们将使用普通的 Core Graphics 函数以绘制到一个 Graphics Context 上来做到这一点，然后将产生出图像设置为我们 Layer 的 <code>contents</code>。下面是更新后的 <code>-display</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">- (void)display</div><div class="line">&#123;</div><div class="line">    // 获取时间插值</div><div class="line">    float time = [self.presentationLayer time];</div><div class="line"></div><div class="line">    // 创建绘制上下文</div><div class="line">    UIGraphicsBeginImageContextWithOptions(self.bounds.size, NO, 0);</div><div class="line">    CGContextRef ctx = UIGraphicsGetCurrentContext();</div><div class="line"></div><div class="line">    // 绘制时钟面板</div><div class="line">    CGContextSetLineWidth(ctx, 4);</div><div class="line">    CGContextStrokeEllipseInRect(ctx, CGRectInset(self.bounds, 2, 2));</div><div class="line"></div><div class="line">    // 绘制时针</div><div class="line">    CGFloat angle = time / 12.0 * 2.0 * M_PI;</div><div class="line">    CGPoint center = CGPointMake(self.bounds.size.width / 2, self.bounds.size.height / 2);</div><div class="line">    CGContextSetLineWidth(ctx, 4);</div><div class="line">    CGContextMoveToPoint(ctx, center.x, center.y);</div><div class="line">    CGContextAddLineToPoint(ctx, center.x + sin(angle) * 80, center.y - cos(angle) * 80);</div><div class="line">    CGContextStrokePath(ctx);</div><div class="line"></div><div class="line">    // 绘制分针</div><div class="line">    angle = (time - floor(time)) * 2.0 * M_PI;</div><div class="line">    CGContextSetLineWidth(ctx, 2);</div><div class="line">    CGContextMoveToPoint(ctx, center.x, center.y);</div><div class="line">    CGContextAddLineToPoint(ctx, center.x + sin(angle) * 90, center.y - cos(angle) * 90);</div><div class="line">    CGContextStrokePath(ctx);</div><div class="line"></div><div class="line">    //set backing image 设置 contents</div><div class="line">    self.contents = (id)UIGraphicsGetImageFromCurrentImageContext().CGImage;</div><div class="line">    UIGraphicsEndImageContext();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果看起来如下：</p>
<p><img src="http://www.objc.io/images/issue-12/clock2.gif" width="320px"></p>
<p>如你所见，不同于第一个时钟动画，随着时针的变化，分针实际上对每一个小时都会转上满满一圈（就像一个真正的时钟那样），而不仅仅只是通过最短的路径移动到它的最终位置；因为我们正在动画的是 <code>time</code> 值本身而不仅仅是时针或分针的位置，所以上下文信息被保留了。</p>
<p>通过这样的方式绘制一个时钟并不是很理想，因为 Core Graphics 函数没有硬件加速，可能会引起动画帧数的下降。另一种能每秒重绘 <code>contents</code> 图像 60 次的方式是用一个数组存储一些预先绘制好的图像，然后基于合适的插值简单的选择对应的图像即可。实现代码大概如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">const NSInteger hoursOnAClockFace = 12;</div><div class="line"></div><div class="line">- (void)display</div><div class="line">&#123;</div><div class="line">    // 获取时间插值</div><div class="line">    float time = [self.presentationLayer time] / hoursOnAClockFace;</div><div class="line"></div><div class="line">    // 从之前定义好的图像数组里获取图像帧</div><div class="line">    NSInteger numberOfFrames = [self.frames count];</div><div class="line">    NSInteger index = round(time * numberOfFrames) % numberOfFrames;</div><div class="line">    UIImage *frame = self.frames[index];</div><div class="line">    self.contents = (id)frame.CGImage;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过避免在每一帧里都用昂贵的软件绘制，我们能改善动画的性能，但代价是我们需要在内存里存储所有预先绘制的动画帧图像，对于一个复杂的动画来说，这可能造成惊人的内存浪费。</p>
<p>但这提出了一个有趣的可能性。如果我们完全不在 <code>-display</code> 里更新 <code>contents</code> 图像会发生什么？我们做一些其它的事情怎样？</p>
<h2 id="非可视属性的动画"><a href="#非可视属性的动画" class="headerlink" title="非可视属性的动画"></a>非可视属性的动画</h2><p>在 <code>-display</code> 里更新其它 Layer 属性是不必要的，因为我们可以很简单地直接对任何这样的属性做动画，如同我们在第一个时钟面板例子里所做的那样。但如果我们设置一些其它的东西，比如某些完全不和 Layer 相关的东西，会怎样呢？</p>
<p>下面的代码使用一个 <code>CALayer</code> 结合 <code>AVAudioPlayer</code> 来创建一个可动画的音量控制器。通过把音量调到动态 Layer 属性上，我们可以使用 Core Animation 的属性插值来平滑的在两个不同的音量之间渐变，以同样的方式我们可以动画 Layer 上的任何 cosmetic 属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">@interface AudioLayer : CALayer</div><div class="line"></div><div class="line">- (id)initWithAudioFileURL:(NSURL *)URL;</div><div class="line"></div><div class="line">@property (nonatomic, assign) float volume;</div><div class="line"></div><div class="line">- (void)play;</div><div class="line">- (void)stop;</div><div class="line">- (BOOL)isPlaying;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">@interface AudioLayer ()</div><div class="line"></div><div class="line">@property (nonatomic, strong) AVAudioPlayer *player;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">@implementation AudioLayer</div><div class="line"></div><div class="line">@dynamic volume;</div><div class="line"></div><div class="line">- (id)initWithAudioFileURL:(NSURL *)URL</div><div class="line">&#123;</div><div class="line">    if ((self = [self init]))</div><div class="line">    &#123;</div><div class="line">        self.volume = 1.0;</div><div class="line">        self.player = [[AVAudioPlayer alloc] initWithContentsOfURL:URL error:NULL];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)play</div><div class="line">&#123;</div><div class="line">    [self.player play];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)stop</div><div class="line">&#123;</div><div class="line">    [self.player stop];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (BOOL)isPlaying</div><div class="line">&#123;</div><div class="line">    return self.player.playing;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (BOOL)needsDisplayForKey:(NSString *)key</div><div class="line">&#123;</div><div class="line">    if ([@&quot;volume&quot; isEqualToString:key])</div><div class="line">    &#123;</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    return [super needsDisplayForKey:key];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id&lt;CAAction&gt;)actionForKey:(NSString *)key</div><div class="line">&#123;</div><div class="line">    if ([key isEqualToString:@&quot;volume&quot;])</div><div class="line">    &#123;</div><div class="line">        CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:key];</div><div class="line">        animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear];</div><div class="line">        animation.fromValue = @([[self presentationLayer] volume]);</div><div class="line">        return animation;</div><div class="line">    &#125;</div><div class="line">    return [super actionForKey:key];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)display</div><div class="line">&#123;</div><div class="line">    // 设置音量值为合适的音量插值</div><div class="line">    self.player.volume = [self.presentationLayer volume];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>我们可以通过使用一个简单的有着播放、停止、音量增大以及音量减小按钮的 View Controller 来做测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, strong) AudioLayer *audioLayer;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line"></div><div class="line">    NSURL *musicURL = [NSURL fileURLWithPath:[[NSBundle mainBundle] pathForResource:@&quot;music&quot; ofType:@&quot;caf&quot;]];</div><div class="line">    self.audioLayer = [[AudioLayer alloc] initWithAudioFileURL:musicURL];</div><div class="line">    [self.view.layer addSublayer:self.audioLayer];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (IBAction)playPauseMusic:(UIButton *)sender</div><div class="line">&#123;</div><div class="line">    if ([self.audioLayer isPlaying])</div><div class="line">    &#123;</div><div class="line">        [self.audioLayer stop];</div><div class="line">        [sender setTitle:@&quot;Play Music&quot; forState:UIControlStateNormal];</div><div class="line">    &#125;</div><div class="line">    else</div><div class="line">    &#123;</div><div class="line">        [self.audioLayer play];</div><div class="line">        [sender setTitle:@&quot;Pause Music&quot; forState:UIControlStateNormal];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (IBAction)fadeIn</div><div class="line">&#123;</div><div class="line">    self.audioLayer.volume = 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (IBAction)fadeOut</div><div class="line">&#123;</div><div class="line">    self.audioLayer.volume = 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>注意：尽管我们的 Layer 没有可见的外观，但它依然需要被添加到屏幕上的视图层级里，以便动画能正常工作。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p><code>CALayer</code> 的动态属性提供了一个简单的机制来实现任何形式的动画——不仅仅只是内建的那些——而通过覆写 <code>-display</code> 方法，我们可以使用这些属性去控制任何我们想控制的东西，甚至是音量值这样的东西。</p>
<p>通过使用这些属性，我们不仅仅避免了重复造轮子，同时还确保了我们的自定义动画能与标准动画的时机和控制函数协同工作，以此就能非常容易地与其它动画属性同步。</p>
<p>===============</p>
<p>译者注：欢迎非商业转载，但请一定注明出处：<a href="https://github.com/nixzhu/dev-blog" target="_blank" rel="external">https://github.com/nixzhu/dev-blog</a> ！</p>
<p>欢迎转发此条微博 <a href="http://weibo.com/2076580237/B3CtbFvP6" target="_blank" rel="external">http://weibo.com/2076580237/B3CtbFvP6</a> 以分享给更多人！</p>
<p>如果你认为这篇翻译不错，也有闲钱，那你可以用支付宝随便捐助一点，以慰劳译者的辛苦：</p>
<p><img src="https://github.com/nixzhu/dev-blog/raw/master/images/nixzhu_alipay.png" alt="nixzhu的支付宝二维码"></p>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="external">Creative Commons BY-NC-ND 3.0</a></p>

  </section>

  
  
</article>


            <footer class="footer">

    <span class="footer__copyright">&copy; 2014-2015. | 由<a href="https://hexo.io/">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno">Huno</a></span>
    
</footer>
        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>
